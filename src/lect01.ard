-- 1. Процесс установки vclang описан на этой странице https://arend.top/getting-started/

-- 2. Примеры определений функций. В комментариях указаны аналогичные определения на хаскелле для сравнения.

\func f => 0 -- константа.
{- Haskell:
   f = 0
-}

\func g : Nat => 0 -- константа с явно указанным типом.
{- Haskell:
   g :: Nat
   g = 0
-}

\func id (x : Nat) => x -- тождественная функция на типе натуральных чисел.
\func id' (x : Nat) : Nat => x  -- тождественная функция на типе натуральных чисел с явно указанным типом результата.
\func id+ (x : Nat) => x -- в идентификаторах могут встречаться произвольные символы.
\func id'' (x:Nat -- x:Nat -- валидный идентификатор.
   :
                    -- пробельные символы игнорируются.
   Nat) => x:Nat
{- Haskell:
   id :: Nat -> Nat
   id x = x
-}

-- \func id''' x => x -- типы аргументов всегда обязательно указывать. Это определение некорректно в отличии от хаскелла.
{- Haskell:
   id''' x = x
-}

\func foo (x : Nat) (y : Int) (z : Nat) => x -- функция от трех аргументов, возвращающая первый.
{- Haskell:
   foo :: Nat -> Int -> Nat -> Nat
   foo x y z = x
-}

-- bar :: Nat -> Nat -> Nat
-- bar x _ = x
\func bar' (x : Nat) (_ : Nat) => x -- функция от двух аргументов, возвращающая первый. Если аргумент не используется, это можно явно обозначить, используя _ вместо имени.
\func bar (x _ : Nat) => x -- если типы подряд идущих аргументов совпадают, их можно объекдинить.

\func bar'' => \lam (x : Nat) (y : Nat) => x -- вместо параметров функции можно использовать лямбды. Необходимо явно указывать тип параметров лямбды (в данном случае), так как его невозможно вывести в языке с зависимыми типами.
\func bar''' => \lam (x y : Nat) => x -- можно сокращать как и раньше.
\func bar'''' : Nat -> Nat -> Nat => \lam x y => x -- если явно указать тип функции, то типы параметров можно не указывать, так как они могут быть выведены.
{- Haskell:
   bar'' :: Nat -> Nat -> Nat
   bar'' = \x y -> x
-}

-- 3. Инфиксные операторы.

\func $ (x y : Nat) => x -- в отличии от хаскелла $ не является инфиксным оператором.
\func test => $ 3 7 -- test возвращает 3.
{- Haskell:
   ($) x y = x
   test = ($) 3 7
-}

\func \infixl 6 $$ (x y : Nat) => x -- чтобы сделать идентификатор инфиксным, нужно явно указать одну из аннотаций \infix, \infixl, \infixr. В отличии от хаскелла аннотация указывается непосредственно перед объявляемым идентификатором.
\func test' => 3 $$ 7 -- test' возвращает 3.
{- Haskell:
   infixl 6 $$
   ($$) x y = x
   test' = 3 $$ 7
-}

\func ff (x y : Nat) => x
\func ff_test => 0 `ff` 1 -- любую функцию можно использовать в инфиксной форму, окружив ее в ` `.
{- Haskell:
   ff x y = x
   ff_test = 3 `ff` 7
-}

\func \fixl 6 ff' (x y : Nat) => x -- аннотации \fix, \fixl, \fixr не делают идентификатор инфиксным, но влияют на его приоритет, когда он используется с ` `.
\func \fixr 6 ff'' (x y : Nat) => x
\func ff'_test => 0 `ff'` 1 `ff'` 2 -- равно (0 `ff'` 1) `ff'` 2
\func ff''_test => 0 `ff''` 1 `ff''` 2 -- равно 0 `ff''` (1 `ff''` 2)
{- Haskell:
   infixl 6 `ff'`
   ff' x y = x
   ff'_test = 0 `ff'` 1 `ff'` 2
   infixr 6 `ff''`
   ff'' x y = x
   ff''_test = 0 `ff''` 1 `ff''` 2
-}

\func \infix 5 %% (x y : Nat) => x
\func %%-test => %% 3 7 -- любой инфиксный оператор можно использовать в префиксной форме. Его не обязательно окружать в ( ).
{- Haskell:
   infix 5 %%
   (%%) x y = x
   pp_test = (%%) 3 7
-}

\func %%-test' => (3 %%) -- можно использовать левое сечение.
{- Haskell:
   pp_test' = (3 %%)
-}

\func %%-test'' => (%% 7) -- т.к. %% 7 -- это корректный синтаксис, то это выражение эквивалентно %% 7, то есть правое сечение использовать нельзя.
{- Haskell:
   pp_test'' = (%%) 7
-}

\func func (x : Nat) => x
\func funcTest => 0 `func -- любой индетификатор можно использовать в постфиксной форме, поставив перед ним `.
{- Haskell:
   -- нет прямого аналога.
   func x = x
   funcTest => func 0
-}
